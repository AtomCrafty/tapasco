//
// Generated by Bluespec Compiler, version 2017.07.A (build 1da80f1, 2017-07-21)
//
// On Fri Aug 17 19:57:39 CEST 2018
//
//
// Ports:
// Name                         I/O  size props
// axis_M_tDATA                   O    64
// axis_M_tVALID                  O     1 reg
// axis_M_tKEEP                   O     8
// axis_M_tLAST                   O     1
// axis_M_tSTRB                   O     8
// axis_M_tID                     O     8
// axis_M_tDEST                   O     4
// axis_M_tUSER                   O     1
// axis_S_tREADY                  O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// axis_M_tREADY                  I     1
// axis_S_tDATA                   I    64 reg
// axis_S_tVALID                  I     1
// axis_S_tKEEP                   I     8 reg
// axis_S_tLAST                   I     1 reg
// axis_S_tSTRB                   I     8 reg
// axis_S_tID                     I     8 reg
// axis_S_tDEST                   I     4 reg
// axis_S_tUSER                   I     1 reg
// maxClients                     I     5
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkAXIS_Arbiter(CLK,
		      RST_N,

		      axis_M_tDATA,

		      axis_M_tREADY,

		      axis_M_tVALID,

		      axis_M_tKEEP,

		      axis_M_tLAST,

		      axis_M_tSTRB,

		      axis_M_tID,

		      axis_M_tDEST,

		      axis_M_tUSER,

		      axis_S_tDATA,

		      axis_S_tREADY,

		      axis_S_tVALID,

		      axis_S_tKEEP,

		      axis_S_tLAST,

		      axis_S_tSTRB,

		      axis_S_tID,

		      axis_S_tDEST,

		      axis_S_tUSER,

		      maxClients);
  input  CLK;
  input  RST_N;

  // value method axis_M_m_AXI_tDATA
  output [63 : 0] axis_M_tDATA;

  // action method axis_M_m_AXI_tREADY
  input  axis_M_tREADY;

  // value method axis_M_m_AXI_tVALID
  output axis_M_tVALID;

  // value method axis_M_m_AXI_tKEEP
  output [7 : 0] axis_M_tKEEP;

  // value method axis_M_m_AXI_tLAST
  output axis_M_tLAST;

  // value method axis_M_m_AXI_tSTRB
  output [7 : 0] axis_M_tSTRB;

  // value method axis_M_m_AXI_tID
  output [7 : 0] axis_M_tID;

  // value method axis_M_m_AXI_tDEST
  output [3 : 0] axis_M_tDEST;

  // value method axis_M_m_AXI_tUSER
  output axis_M_tUSER;

  // action method axis_S_s_AXI_tDATA
  input  [63 : 0] axis_S_tDATA;

  // value method axis_S_s_AXI_tREADY
  output axis_S_tREADY;

  // action method axis_S_s_AXI_tVALID
  input  axis_S_tVALID;

  // action method axis_S_s_AXI_tKEEP
  input  [7 : 0] axis_S_tKEEP;

  // action method axis_S_s_AXI_tLAST
  input  axis_S_tLAST;

  // action method axis_S_s_AXI_tSTRB
  input  [7 : 0] axis_S_tSTRB;

  // action method axis_S_s_AXI_tID
  input  [7 : 0] axis_S_tID;

  // action method axis_S_s_AXI_tDEST
  input  [3 : 0] axis_S_tDEST;

  // action method axis_S_s_AXI_tUSER
  input  axis_S_tUSER;

  // action method arbiter_turnover
  input  [4 : 0] maxClients;

  // signals for module outputs
  wire [63 : 0] axis_M_tDATA;
  wire [7 : 0] axis_M_tID, axis_M_tKEEP, axis_M_tSTRB;
  wire [3 : 0] axis_M_tDEST;
  wire axis_M_tLAST, axis_M_tUSER, axis_M_tVALID, axis_S_tREADY;

  // register arbiter
  reg [4 : 0] arbiter;
  wire [4 : 0] arbiter$D_IN;
  wire arbiter$EN;

  // ports of submodule streamIn_outp
  wire [93 : 0] streamIn_outp$D_IN, streamIn_outp$D_OUT;
  wire streamIn_outp$CLR,
       streamIn_outp$DEQ,
       streamIn_outp$EMPTY_N,
       streamIn_outp$ENQ,
       streamIn_outp$FULL_N;

  // ports of submodule streamOut_inp
  wire [93 : 0] streamOut_inp$D_IN, streamOut_inp$D_OUT;
  wire streamOut_inp$CLR,
       streamOut_inp$DEQ,
       streamOut_inp$EMPTY_N,
       streamOut_inp$ENQ,
       streamOut_inp$FULL_N;

  // remaining internal signals
  wire [4 : 0] arbiter_8_PLUS_1_3_REM_IF_turnover_whas__4_THE_ETC___d57,
	       x__h2173;

  // value method axis_M_m_AXI_tDATA
  assign axis_M_tDATA =
	     streamOut_inp$EMPTY_N ? streamOut_inp$D_OUT[93:30] : 64'd0 ;

  // value method axis_M_m_AXI_tVALID
  assign axis_M_tVALID = streamOut_inp$EMPTY_N ;

  // value method axis_M_m_AXI_tKEEP
  assign axis_M_tKEEP =
	     streamOut_inp$EMPTY_N ? streamOut_inp$D_OUT[29:22] : 8'd0 ;

  // value method axis_M_m_AXI_tLAST
  assign axis_M_tLAST = streamOut_inp$EMPTY_N && streamOut_inp$D_OUT[21] ;

  // value method axis_M_m_AXI_tSTRB
  assign axis_M_tSTRB =
	     streamOut_inp$EMPTY_N ? streamOut_inp$D_OUT[20:13] : 8'd0 ;

  // value method axis_M_m_AXI_tID
  assign axis_M_tID =
	     streamOut_inp$EMPTY_N ? streamOut_inp$D_OUT[12:5] : 8'd0 ;

  // value method axis_M_m_AXI_tDEST
  assign axis_M_tDEST =
	     streamOut_inp$EMPTY_N ? streamOut_inp$D_OUT[4:1] : 4'd0 ;

  // value method axis_M_m_AXI_tUSER
  assign axis_M_tUSER = streamOut_inp$EMPTY_N && streamOut_inp$D_OUT[0] ;

  // value method axis_S_s_AXI_tREADY
  assign axis_S_tREADY = 1'b1 ;

  // submodule streamIn_outp
  FIFO2 #(.width(32'd94), .guarded(32'd1)) streamIn_outp(.RST(RST_N),
							 .CLK(CLK),
							 .D_IN(streamIn_outp$D_IN),
							 .ENQ(streamIn_outp$ENQ),
							 .DEQ(streamIn_outp$DEQ),
							 .CLR(streamIn_outp$CLR),
							 .D_OUT(streamIn_outp$D_OUT),
							 .FULL_N(streamIn_outp$FULL_N),
							 .EMPTY_N(streamIn_outp$EMPTY_N));

  // submodule streamOut_inp
  FIFO2 #(.width(32'd94), .guarded(32'd1)) streamOut_inp(.RST(RST_N),
							 .CLK(CLK),
							 .D_IN(streamOut_inp$D_IN),
							 .ENQ(streamOut_inp$ENQ),
							 .DEQ(streamOut_inp$DEQ),
							 .CLR(streamOut_inp$CLR),
							 .D_OUT(streamOut_inp$D_OUT),
							 .FULL_N(streamOut_inp$FULL_N),
							 .EMPTY_N(streamOut_inp$EMPTY_N));

  // register arbiter
  assign arbiter$D_IN =
	     streamIn_outp$D_OUT[21] ?
	       arbiter_8_PLUS_1_3_REM_IF_turnover_whas__4_THE_ETC___d57 :
	       arbiter ;
  assign arbiter$EN = streamIn_outp$EMPTY_N && streamOut_inp$FULL_N ;

  // submodule streamIn_outp
  assign streamIn_outp$D_IN =
	     { axis_S_tDATA,
	       axis_S_tKEEP,
	       axis_S_tLAST,
	       axis_S_tSTRB,
	       axis_S_tID,
	       axis_S_tDEST,
	       axis_S_tUSER } ;
  assign streamIn_outp$ENQ = streamIn_outp$FULL_N && axis_S_tVALID ;
  assign streamIn_outp$DEQ = streamIn_outp$EMPTY_N && streamOut_inp$FULL_N ;
  assign streamIn_outp$CLR = 1'b0 ;

  // submodule streamOut_inp
  assign streamOut_inp$D_IN =
	     { streamIn_outp$D_OUT[93:5],
	       arbiter[3:0],
	       streamIn_outp$D_OUT[0] } ;
  assign streamOut_inp$ENQ = streamIn_outp$EMPTY_N && streamOut_inp$FULL_N ;
  assign streamOut_inp$DEQ = streamOut_inp$EMPTY_N && axis_M_tREADY ;
  assign streamOut_inp$CLR = 1'b0 ;

  // remaining internal signals
  assign arbiter_8_PLUS_1_3_REM_IF_turnover_whas__4_THE_ETC___d57 =
	     x__h2173 % maxClients ;
  assign x__h2173 = arbiter + 5'd1 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        arbiter <= `BSV_ASSIGNMENT_DELAY 5'd0;
      end
    else
      begin
        if (arbiter$EN) arbiter <= `BSV_ASSIGNMENT_DELAY arbiter$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    arbiter = 5'h0A;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkAXIS_Arbiter

