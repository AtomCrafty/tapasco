%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Architecture Implementation}\label{sec:architecture-implementation}%
An implementation of an \gloss{Architecture} for \tpc{} consists of several parts:
A set of \emph{directive templates for high-level synthesis} (see \secref{sec:ai-hls}), a \emph{Tcl library} implementation of the API shown in \tblref{tbl:architecture.tcl} (see \secref{sec:ai-mls}) and an \emph{implementation of the \gloss{TPC API}}, which is discussed in more detail in \secref{sec:ai-tpcapi}.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{HLS Directive Templates}\label{sec:ai-hls}%
The Tcl script driving HLS is generated from \code{common/hls.tcl.template} and contains three major insert points for the \gloss{Architecture} to define the interfaces of the hardware thread:
the key \code{HLSTclTemplate} in the \gloss{Architecture Description} (see \tblref{tbl:architecture-description}) can be used to include a code file with general configuration directives at the start of HLS.
\tpc{} automatically instantiates the \code{ValueArgTemplate} and \code{ReferenceArgTemplate} files for each corresponding value and reference argument of the kernel being synthesized.
A template file can use the placeholders \code{@@ARG@@} and \code{@@TOP@@} to reference the current argument name and the top-level function name respectively.
Example:
%
\begin{lstlisting}[language={[TemplateTcl]Tcl}]
set_directive_interface -mode m_axi -offset slave @@TOP@@ @@ARG@@
\end{lstlisting}
%
This template would instruct Vivado HLS to generate an AXI4 Master interface for each argument this template is applied to.
For more information on the available directives, see \cite{ug902}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{MLS Tcl Library}\label{sec:ai-mls}%
The instantiation of the abstract \gloss{Architecture} is done in the Tcl library that must be provided by an \gloss{Architecture} implementation that is used in MLS, as described in \secref{sec:mls}.
To implement the calls in \tblref{tbl:architecture.tcl}, several helper functions are provided in \tblref{tbl:common.tcl} and are available to the implementation.
Most importantly, the \code{tpc\_get\_composition} function can be used to retrieve an array of (VLNV, count) pairs which reflects the current \gloss{Composition} to create in the call to \code{arch\_create}.
The architecture must instantiate the entire threadpool infrastructure and connect it to one of the three outlets provided by API calls (cf. \figref{fig:arch-ports}):
%
\begin{enumerate}
  \item \code{arch\_get\_slaves} should return the outermost set of AXI4 Slave interfaces that need to be connected to the host via the \gloss{Platform} to provide host access to the threadpool hardware registers. Note that \gloss{Platform} implementations may impose limits on the number of such masters; e.g., the \code{zynq} \gloss{Platform} currently only supports one.
  %
  \item \code{arch\_get\_masters} should return the outermost set of AXI4 Master interfaces that need to be connected to memory via the \gloss{Platform}. Limits of the \gloss{Platform} may also apply similarly as for the slaves.
  %
  \item \code{arch\_get\_irqs} should return all interrupt lines which need to be connected to the host. The principal order of the lines will be preserved by the \gloss{Platform} implementation; e.g., the \code{zynq} architecture will instantiate an AXI4 interrupt controller for each 32 interrupt lines.
\end{enumerate}
%
\begin{figure}
  \centering%
  \includegraphics[]{tikz/tpc-structure-conn-ann}
  \caption{FPGA Design: Architecture ports.}
  \label{fig:arch-ports}
\end{figure}

