%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Description Files}\label{sec:description-files}%
The configuration of each step and part of \tpc{} is provided by \gloss{Description Files}.
\gloss{Description Files} are plain-text configuration files, which provide key-value maps in the extremely simple line-based notation \code{<KEY> '=' <VALUE>}.
The format is meant to be easily editable in text editor, as well as produceable by reasonably simple scripts or support tools.
It is \emph{case-insensitive} and permits \emph{comment lines}, which start with a non-alphanumeric character. \lstref{lst:description-example} shows an example file.
In general, all paths to files are interpreted as relative to the \gloss{Description File}'s location, except when an absolute path is given.
%
\lstinputlisting[caption={Example Description File: 'add' Kernel.}, label={lst:description-example}, lastline=4, language=kernel]{misc/kernel.description}
%
\tpc{} uses five kinds of description files:

\begin{compactenum}
  \item \gloss{Kernel Descriptions}
  \item \gloss{Architecture Descriptions}
  \item \gloss{Platform Descriptions}
  \item \gloss{Run Descriptions}
  \item \gloss{Bitstream Descriptions}
\end{compactenum}
Each of these files will be described in more detail in the following.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Kernel Descriptions}
A \gloss{Kernel Description} contains additional information about a kernel, mostly concerning its interface.
Most importantly, \tpc{} currently distinguishes two \emph{passing conventions} for arguments:
%
\begin{itemize}
  \item \emph{value arguments} are passed by-value; depending on the \gloss{Architecture}, they are often implemented using hardware registers.
  \item \emph{reference arguments} are passed by-reference; their synthesis depends on the memory access patterns, in the most general case of random access the \gloss{Architecture} will generate \emph{bus masters} to access device memory and a base address register for such kernel arguments.
\end{itemize}
\tblref{tbl:kernel-description} contains a description of all currently defined keys for \gloss{Kernel Descriptions}.

\begin{longtable}[c]{>{\sffamily}L{0.2\textwidth}L{0.35\textwidth}>{\ttfamily\footnotesize}L{.35\textwidth}}
  \caption{Kernel Description: Description Keys.}
  \label{tbl:kernel-description}\\
  \toprule
  \normalfont\normalsize\textbf{Key} & \textbf{Comment} & \normalfont\normalsize\textbf{Example} \\\midrule
  \endhead
  \bottomrule
  \endlastfoot
  Description & Short kernel description. & Description = Signed 16-bit saturated adder.\\\midrule
  Files & Source files containing the kernel code and required data structures. \textbf{Mandatory.} & Files = src/add.c add-helper.c \\\midrule
  FilesCFlags & Additional C/C++ compiler flags necessary for compilation. & FilesCFlags = -DUSE\_FEATURE \\\midrule
  Kernel & Name of top-level function to synthesize. \textbf{Mandatory.} & Kernel = add \\\midrule
  Name & Name of the synthesized IP core. & Name = SatAdder \\\midrule
  OtherDirectives & Filename of external directives file for HLS. Can be used to supply kernel-specific optimizations. & OtherDirectives = kernel.dir\\\midrule
  ReferenceArgs & Names of arguments to be synthesized as pass-by-reference. & ReferenceArgs = arr1 xarr\\\midrule
  TestbenchCFlags & Additional C/C++ compiler flags necessary to compile the testbench standalone. & TestbenchCFlags = -O3 -g\\\midrule
  TestbenchFiles & Source files for a standalone unit test for the kernel. Must contain a regular \code{main()} that returns 0 if test was successful. & TestbenchFiles = test\_add.c \\\midrule
  ValueArgs & Names of arguments to be synthesized as pass-by-value. & ValueArgs = x y z\\\midrule
  Version & Version number for the kernel. \textbf{Mandatory.} & Version = 1.0 \\
\end{longtable}

\paragraph{Example}
To illustrate the usage of \gloss{Kernel Descriptions}, consider the \code{add} \gloss{Kernel} in the directory \code{\$TPC\_HOME/kernel/add}; the top-level function is defined in \code{add.c}:
%
\lstinputlisting[language=C]{misc/add.c}
%
Both arguments are passed by value, the \code{kernel.description} therefore looks like this:
%
\lstinputlisting[language=kernel]{misc/kernel.description}
%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Architecture Descriptions}
An \gloss{Architecture Description} defines an abstract threadpool architecture, the required hardware thread interfaces and organizes supporting files to create the IP cores in high-level synthesis and instantiate the architecture during mid-level synthesis.
\tblref{tbl:architecture-description} contains a description for all currently defined keys for \gloss{Architecture Description}.
See \secref{sec:architecture-implementation} for details on implementing an \gloss{Architecture} for \tpc{}.

\begin{longtable}[c]{>{\sffamily}L{0.2\textwidth}L{0.35\textwidth}>{\ttfamily\footnotesize}L{.35\textwidth}}
  \caption{Architecture Description: Description Keys.}
  \label{tbl:architecture-description}\\
  \toprule
  \normalfont\normalsize\textbf{Key} & \textbf{Comment} & \normalfont\normalsize\textbf{Example} \\\midrule
  \endhead
  \bottomrule
  \endlastfoot
  Description & Short architecture description. & Description = Baseline AXI4 architecture. \\\midrule
  HLSTclTemplate & Template file for HLS Tcl script. Contains placeholders of the form \code{@@PLACEHOLDER@@}. Default: \code{hls.tcl.template}. & HLSTclTemplate = hls.script \\\midrule
  Name & Name of the architecture. \textbf{Mandatory.} & Name = baseline\\\midrule
  ReferenceArgTemplate & Template file for reference arguments. Used in script generation for each reference argument. Default: \code{referencearg.directives. template} & ReferenceArgTemplate = refarg.dir \\\midrule
  TclHeader & Path to additional Tcl script to be included at the top of the generated HLS script. & TclHeader = ../common/common.tcl \\\midrule
  TclLibrary & Path to Tcl script library to instantiate the architecture. Default: \code{architecture.tcl} & TclLibrary = baseline.tcl \\\midrule
  ValueArgTemplate & Template file for value arguments. Used in script generation for each reference argument. Default: \code{valuearg.directives. template} & ValueArgTemplate = valarg.dir \\
\end{longtable}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Platform Descriptions}
\gloss{Platform Descriptions} defines a platform for a given FPGA board/device by defining the connections between host and threadpool, threadpool and memory, and the signaling mechanism to be used.
\tblref{tbl:platform-description} contains a description for all currently defined keys for \gloss{Platform Description}.
See \secref{sec:platform-implementation} for details on implementing a \gloss{Platform} for \tpc{}.

\begin{longtable}[c]{>{\sffamily}L{0.2\textwidth}L{0.35\textwidth}>{\ttfamily\footnotesize}L{.35\textwidth}}
  \caption{Platform Description: Description Keys.}
  \label{tbl:platform-description}\\
  \toprule
  \normalfont\normalsize\textbf{Key} & \textbf{Comment} & \normalfont\normalsize\textbf{Example} \\\midrule
  \endhead
  \bottomrule
  \endlastfoot
  API & Simulation: SystemVerilog include containing \gloss{Platform API} implementation. Default: \code{include/platform-api.svh} & API = include/zynq-api.svh \\\midrule
  BoardPart & Board part VLNV identifier (Vendor-Library-Name-Version). \textbf{Mandatory.} & BoardPart = xilinx.com:zc706:part0:1.1 \\\midrule
  Description & Short platform description. & Description = Platform for Zynq-7000 series devices. \\\midrule
  Harness & Simulation: SystemVerilog include containing harness code to drive the testbench module, i.e., clock generation, setup processes etc. Default: \code{include/platform-harness.svh} & Harness = include/zynq-harness.svh \\\midrule
  Name & Name of the platform. \textbf{Mandatory.} & Name = zynq \\\midrule
  Part & Part identifier for the FPGA. \textbf{Mandatory.} & Part = xc7z045ffg900-2 \\\midrule
  TclLibrary & Path to Tcl script library to instantiate the platform. Default: \code{platform.tcl} & TclLibrary = zynq.tcl\\\midrule
  TestbenchTemplate & Simulation: Path to testbench module template. Default: \code{sv/platform-dpi.sv} & TestbenchTemplate = mod.sv \\
\end{longtable}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Run Descriptions}
A \gloss{Run Description} file contains arguments which could otherwise be provided to the \code{compose} command via command line. 
\tblref{tbl:run-description} contains a description for all currently defined keys for \gloss{Run Description}.

\begin{longtable}[c]{>{\sffamily}L{0.2\textwidth}L{0.35\textwidth}>{\ttfamily\footnotesize}L{0.35\textwidth}}
  \caption{Run Description: Description Keys.} \\
  \toprule
  \label{tbl:run-description}
  \normalfont\normalsize\textbf{Key} & \textbf{Comment} & \normalfont\normalsize\textbf{Example} \\\midrule
  \endfirsthead
  \caption[]{Run Description (continued): Description Keys.}\\
  \toprule
  \normalfont\normalsize\textbf{Key} & \textbf{Comment} & \normalfont\normalsize\textbf{Example} \\\midrule
  \endhead
  \bottomrule
  \endlastfoot
  ArchDir & Base directory for \gloss{Architecture Descriptions}. Default: \code{arch} & archDir = myArchs \\\midrule
  Architecture & Name of specific architecture to compose. & Architecture = baseline \\\midrule
  Bitstream & Name of specific \gloss{Bitstream Description} to compose. & Bitstream = example.bd \\\midrule
  BitstreamDir & Base directory for \gloss{Bitstream Descriptions}. Default: \code{bd} & bitstreamDir = myBitstreams \\\midrule
  CommonDir & Base directory for \tpc{} common files. Default: \code{common} & commonDir = myCommon\\\midrule
  Kernel & HLS: Name of specific kernel to synthesize. & Kernel = add \\\midrule
  KernelDir & Base directory for \gloss{Kernel Descriptions}. Default: \code{kernel} & kernelDir = myKernels \\\midrule
  Platform & Name of specific platform to compose. & Platform = zynq \\\midrule
  PlatformDir & Base directory for \gloss{Platform Descriptions}. Default: \code{platform} & platformDir = myPlatforms \\
\end{longtable}

\paragraph{Example}
As an example, consider the run description file \code{add.cfg} in \code{\$TPC\_HOME/\allowbreak examples/\allowbreak add/}:
%
\lstinputlisting[language=run]{misc/add.cfg}
%
Note how \code{Bitstream = add.bd} references a \gloss{Bitstream Description} in the same directory.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Bitstream Descriptions}
\gloss{Bitstream Descriptions} contain information about a specific \emph{threadpool composition}.
\tblref{tbl:bitstream-description} contains a description for all currently defined keys for \gloss{Bitstream Description}.

\begin{longtable}[c]{>{\sffamily}L{0.2\textwidth}L{0.35\textwidth}>{\ttfamily\footnotesize}L{.35\textwidth}}
  \caption{Bitstream Description: Description Keys.}
  \label{tbl:bitstream-description}\\
  \toprule
  \normalfont\normalsize\textbf{Key} & \textbf{Comment} & \normalfont\normalsize\textbf{Example} \\\midrule
  \endhead
  \bottomrule
  \endlastfoot
  Composition & Space separated pairs of kernel name and instance counts. & Composition = add 3 warraw 15 \\
\end{longtable}

