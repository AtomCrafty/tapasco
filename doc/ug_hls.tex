%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{High-Level Synthesis}\label{sec:hls}%
This section describes the first step of the overall flow, \emph{high-level synthesis (HLS)}, in more detail.
Since this step can be crucial to obtain adequate performance for the kernels, it can be performed separately via the \code{hls} sbt task (see \secref{sec:basic-usage}).
At the time of writing, HLS is performed by Xilinx's Vivado HLS, part of the Vivado Design Suite.
Like most components of the Vivado Design Suite, Vivado HLS offers Tcl scriptability, which makes the automation of processes considerably easier.

\subsection*{Script Assembly}
For each \gloss{Kernel}, \tpc{} assembles a Tcl script that drives the execution of Vivado HLS to synthesize IP cores from the kernel code.
There is a common template file (contents are shown in \lstref{lst:hls-tcl-template}), which is completed by \tpc{} using two additional templates provided by the chosen \gloss{Architecture} implementation:
%
\begin{enumerate}
  \item \code{ValueArgTemplate} --- Contains a set of synthesis directives used for each value argument.
  \item \code{ReferenceArgTemplate} --- Contains a set of synthesis directives used for each reference argument.
\end{enumerate}
%
this allows the \gloss{Architecture} to control the exact synthesis of each argument.
Consider the contents of the value argument template for the 'baseline' \gloss{Architecture} as an example:
\lstinputlisting[language={[TemplateTcl]Tcl}, firstline=2]{misc/valuearg.directives.template}
This single directive specifies that each value argument should be synthesized as a hardware register with an AXI4Lite interface.
When defining an \gloss{Architecture}, the whole set of Vivado HLS directives can be utilized in this manner.
For more information about directives, refer to \cite{ug902}.
%
\lstinputlisting[caption={Contents of common/hls.tcl.template.}, label={lst:hls-tcl-template}, language={[TemplateTcl]Tcl}, breaklines=true]{misc/hls.tcl.template}
% 
\paragraph{Co-Simulation}
In order to verify the functionality of the hardware descriptions generated by HLS it is very useful to provide a \emph{testbench} written in C/C++.
The convention used here is to implement a simple \code{main()} which runs a number of tests and exits with return code 0 if they were successful.
If supplied in the \gloss{Kernel Description} key \code{TestbenchFiles}, this testbench code can be used by Vivado HLS to generate \emph{golden input/output data pairs} and a self-checking testbench module in HDL for the the kernel.
RTL simulation can then be used to compare the golden set to the input/output data generated by the hardware description in simulation.
See the subdirectories of \code{kernel} in \tpchome{} for examples of such testbenches.

\medskip
\begin{note}
This step is vital to ensure that the designs created by \tpc{} are working.
This works particularly well with test-driven development and is similar to unit testing.
It alerts the user early on if something is broken in the original code, which is much easier than tracing errors in the complete design and saves valuable time in debugging.
\end{note}
