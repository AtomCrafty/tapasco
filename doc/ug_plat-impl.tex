%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Platform Implementation}\label{sec:platform-implementation}%
An implementation of a \gloss{Platform} for \tpc{} consists of several parts:
A \emph{Tcl library} implementation of the API shown in \tblref{tbl:platform.tcl} (see \secref{sec:mls-papi}), a \emph{SystemVerilog implementation of the \gloss{Platform API}} discussed in \secref{sec:pi-papi} for simulation and a \emph{device driver implementation of the \gloss{Platform API}} for execution on the actual hardware.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{MLS Tcl Library}\label{sec:mls-papi}%
A new \gloss{Platform} must provide a Tcl library which allows to instantiate the platform-specific IP cores and connect them to the \gloss{Architecture} during MLS, as described in \secref{sec:mls}.
The API is described in \tblref{tbl:platform.tcl} and can be implemented using the facilities described in \tblref{tbl:common.tcl} and the Vivado IP Integrator Tcl APIs \cite{ug835}.
If necessary, the library can construct different designs, depending on the \code{TPC\_MODE}, e.g., to replace non-simulation cores with simulation models (see \code{tpc\_get\_generate\_mode} Tcl call in \tblref{tbl:common.tcl}).
The two main library calls, \code{platform\_create} and \code{platform\_generate}, must instantiate and connect the platform-specific IP to the threadpool and generate a bitstream or simulation environment, respectively.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Simulation Platform Implementation}\label{sec:pi-sim}%
\tpc{} offers a generic \gloss{Platform API} implementation in \code{platform/\allowbreak common} which connects a process to a remote, simulator-driven \gloss{Platform} using a client-server library based on socket inter-process communication (see \secref{sec:lls-sim} for details).
The server-side uses DPI to call corresponding SystemVerilog tasks in the hardware description.
Since the \gloss{Platform API} calls themselves do not change, it is only necessary to implement the SystemVerilog tasks for a new \gloss{Platform} in the include file linked by the \code{API} key in the \gloss{Platform Description} (see \tblref{tbl:platform-description}).
An exemplary implementation can also be found in the \code{zynq} platform in \code{platform/\allowbreak zynq/\allowbreak include/\allowbreak platform-api.svh}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Device Driver Implementation}\label{sec:pi-dd}%
To execute on actual hardware, it is necessary for a \gloss{Platform} to provide an implementation of the \gloss{Platform API} which interfaces with the real hardware.
Such an implementation must be backed by a device driver which provides the basic interfaces, e.g., a memory-mappable device file to access the control registers, registers interrupt callbacks with the operating system, and similar.
However, \tpc{} does not impose any requirements regarding the realization; required is only that the shared library implementing the \gloss{Platform API} can be run in user mode.
