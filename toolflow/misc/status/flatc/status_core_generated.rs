// automatically generated by the FlatBuffers compiler, do not modify

#![allow(dead_code)]
#![allow(unused_imports)]
extern crate flatbuffers;

pub mod tapasco {
    #![allow(dead_code)]
    #![allow(unused_imports)]

    use std::cmp::Ordering;
    use std::mem;

    extern crate flatbuffers;
    use self::flatbuffers::EndianScalar;

    pub enum PEOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct PE<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PE<'a> {
        type Inner = PE<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> PE<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PE { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PEArgs<'args>,
        ) -> flatbuffers::WIPOffset<PE<'bldr>> {
            let mut builder = PEBuilder::new(_fbb);
            builder.add_offset(args.offset);
            if let Some(x) = args.local_memory {
                builder.add_local_memory(x);
            }
            builder.add_id(args.id);
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_ID: flatbuffers::VOffsetT = 6;
        pub const VT_OFFSET: flatbuffers::VOffsetT = 8;
        pub const VT_LOCAL_MEMORY: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(PE::VT_NAME, None)
        }
        #[inline]
        pub fn id(&self) -> u32 {
            self._tab.get::<u32>(PE::VT_ID, Some(0)).unwrap()
        }
        #[inline]
        pub fn offset(&self) -> u64 {
            self._tab.get::<u64>(PE::VT_OFFSET, Some(0)).unwrap()
        }
        #[inline]
        pub fn local_memory(&self) -> Option<flatbuffers::Vector<'a, u64>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(
                    PE::VT_LOCAL_MEMORY,
                    None,
                )
        }
    }

    pub struct PEArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub id: u32,
        pub offset: u64,
        pub local_memory: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
    }
    impl<'a> Default for PEArgs<'a> {
        #[inline]
        fn default() -> Self {
            PEArgs {
                name: None,
                id: 0,
                offset: 0,
                local_memory: None,
            }
        }
    }
    pub struct PEBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PEBuilder<'a, 'b> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PE::VT_NAME, name);
        }
        #[inline]
        pub fn add_id(&mut self, id: u32) {
            self.fbb_.push_slot::<u32>(PE::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_offset(&mut self, offset: u64) {
            self.fbb_.push_slot::<u64>(PE::VT_OFFSET, offset, 0);
        }
        #[inline]
        pub fn add_local_memory(
            &mut self,
            local_memory: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u64>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PE::VT_LOCAL_MEMORY, local_memory);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PEBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PEBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PE<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum PlatformOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Platform<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Platform<'a> {
        type Inner = Platform<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Platform<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Platform { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PlatformArgs<'args>,
        ) -> flatbuffers::WIPOffset<Platform<'bldr>> {
            let mut builder = PlatformBuilder::new(_fbb);
            builder.add_offset(args.offset);
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_OFFSET: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Platform::VT_NAME, None)
        }
        #[inline]
        pub fn offset(&self) -> u64 {
            self._tab.get::<u64>(Platform::VT_OFFSET, Some(0)).unwrap()
        }
    }

    pub struct PlatformArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub offset: u64,
    }
    impl<'a> Default for PlatformArgs<'a> {
        #[inline]
        fn default() -> Self {
            PlatformArgs {
                name: None,
                offset: 0,
            }
        }
    }
    pub struct PlatformBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PlatformBuilder<'a, 'b> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Platform::VT_NAME, name);
        }
        #[inline]
        pub fn add_offset(&mut self, offset: u64) {
            self.fbb_.push_slot::<u64>(Platform::VT_OFFSET, offset, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PlatformBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PlatformBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Platform<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum StatusOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Status<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Status<'a> {
        type Inner = Status<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Status<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Status { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args StatusArgs<'args>,
        ) -> flatbuffers::WIPOffset<Status<'bldr>> {
            let mut builder = StatusBuilder::new(_fbb);
            builder.add_platform_base(args.platform_base);
            builder.add_arch_base(args.arch_base);
            if let Some(x) = args.platform {
                builder.add_platform(x);
            }
            if let Some(x) = args.pe {
                builder.add_pe(x);
            }
            builder.finish()
        }

        pub const VT_ARCH_BASE: flatbuffers::VOffsetT = 4;
        pub const VT_PLATFORM_BASE: flatbuffers::VOffsetT = 6;
        pub const VT_PE: flatbuffers::VOffsetT = 8;
        pub const VT_PLATFORM: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn arch_base(&self) -> u64 {
            self._tab.get::<u64>(Status::VT_ARCH_BASE, Some(0)).unwrap()
        }
        #[inline]
        pub fn platform_base(&self) -> u64 {
            self._tab
                .get::<u64>(Status::VT_PLATFORM_BASE, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn pe(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<PE<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<PE<'a>>>,
            >>(Status::VT_PE, None)
        }
        #[inline]
        pub fn platform(
            &self,
        ) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Platform<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<Platform<'a>>>,
            >>(Status::VT_PLATFORM, None)
        }
    }

    pub struct StatusArgs<'a> {
        pub arch_base: u64,
        pub platform_base: u64,
        pub pe: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PE<'a>>>>,
        >,
        pub platform: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Platform<'a>>>,
            >,
        >,
    }
    impl<'a> Default for StatusArgs<'a> {
        #[inline]
        fn default() -> Self {
            StatusArgs {
                arch_base: 0,
                platform_base: 0,
                pe: None,
                platform: None,
            }
        }
    }
    pub struct StatusBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> StatusBuilder<'a, 'b> {
        #[inline]
        pub fn add_arch_base(&mut self, arch_base: u64) {
            self.fbb_
                .push_slot::<u64>(Status::VT_ARCH_BASE, arch_base, 0);
        }
        #[inline]
        pub fn add_platform_base(&mut self, platform_base: u64) {
            self.fbb_
                .push_slot::<u64>(Status::VT_PLATFORM_BASE, platform_base, 0);
        }
        #[inline]
        pub fn add_pe(
            &mut self,
            pe: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<PE<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Status::VT_PE, pe);
        }
        #[inline]
        pub fn add_platform(
            &mut self,
            platform: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Platform<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Status::VT_PLATFORM, platform);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StatusBuilder<'a, 'b> {
            let start = _fbb.start_table();
            StatusBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Status<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

} // pub mod Tapasco
